{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Veriviz \u2013 Hardware Security Visualized","text":"<p>Welcome to Veriviz, a platform designed to visualize hardware security research.  Check out the live site here.</p> <p>This website serves as a resource to document Veriviz:</p> <ul> <li>If you want to use Veriviz or see demos, check out the website or contact us!</li> <li>If you want to develop or contribute, see Development, Deployment and Contributing.</li> </ul> <p>Enjoy exploring, and let us know if you have feedback!</p>"},{"location":"#about-verviz","title":"About Verviz","text":"<p>Verviz is a research and visualization platform for hardware security.  Its main objective is to make complex security analyses more accessible  through intuitive front-end views and interactive workflows.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Integrates symbolic execution tools like SEIF and Sylvia.</li> <li>Streamlines the process of analyzing hardware designs for security properties.</li> <li>Deploys seamlessly on OKD at UNC Cloud Apps.</li> </ul> <p>Check out the Repo Structure for an overview of how  this project is organized and how the frontend, backend, SEIF, and Sylvia pieces fit together.</p> <p>Where to go next?</p> <ul> <li>To learn how to contribute, click on the contribute tab</li> <li>To learn more about SEIF and Sylvia, click on the refrences tab</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-the-verviz-website","title":"Contributing to the Verviz Website","text":""},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork and Clone: Fork the Veriviz repository and/or clone it locally.</li> <li>Devcontainer Setup: For a consistent development environment, check out using devcontainers.</li> <li>Create a Branch: Work on your feature or bug fix in a new branch, e.g., <code>git checkout -b feature/amazing-feature</code>.</li> <li>Test and Verify: Ensure everything runs locally before opening a PR. See here for more information on running locally.  </li> <li>If you\u2019d like to deploy changes or see how deployment works, see How to Deploy.</li> </ol> <p>Cloning Sylvia and/or SEIF</p> <p>While not neseary, it is recommended to run things locally to test the full pipeline and your new code works. To tests the entirerty of the pipeline, it is recommended to clone Sylvia and/or SEIF to run these locally as well. Check out below for how to run these locally.</p>"},{"location":"contributing/#mkdocs-and-contributing-to-verviz-docs","title":"MkDocs and Contributing to Verviz Docs","text":""},{"location":"contributing/#what-is-mkdocs","title":"What is MkDocs?","text":"<p>MkDocs is a static site generator built for project documentation.  It uses Markdown files for content and a single <code>mkdocs.yml</code> for config. Read more about mkdocs on their offical documentation website.</p>"},{"location":"contributing/#contributing-to-verviz-docs","title":"Contributing to Verviz Docs","text":"<ol> <li>Fork or clone the Veriviz documentation.</li> <li><code>ctrl + shft + p</code>( <code>cmd + shft + p</code> on mac) and select `reopen in devcontainer. For more information or if not working see using devcontainers</li> </ol> <p>Now automatically, when you commit remotely to the main branch or sucesfully pull request, the website will automatically deploy and reflect your changes. Below are some common tasks that will help you get started.</p>"},{"location":"contributing/#common-tasks","title":"Common Tasks","text":"<ul> <li>Add a new doc: create <code>new_topic.md</code> in <code>docs/</code> and link it in <code>mkdocs.yml</code>. </li> <li>Preview changes: run <code>mkdocs serve</code> to check them locally.</li> <li>Publish: push to <code>main</code> if the pipeline is set to deploy.</li> </ul> <p>On `mkdocs.yml</p> <p>The <code>mkdocs.yml</code> file defines configuration for the mkdocs site in a human readable format. To add your new file to the view of the website, look in the <code>mkdocs.yml</code> file, look for the <code>nav</code> section and and your file with a relative path. For example, if i craeted <code>hello.md</code> in <code>/docs/intros/hello.md</code>, in the <code>nav</code> section i would include: <pre><code>nav:\n    - intros:\n        - NAME HERE(ex. Hello): intros/hello.md\n</code></pre></p>"},{"location":"repo_structure/","title":"Veriviz Structure","text":"<p>Below is a high-level breakdown of the Veriviz repository:</p>"},{"location":"repo_structure/#directory-layout","title":"Directory Layout","text":""},{"location":"repo_structure/#frontend","title":"<code>frontend/</code>","text":"<ul> <li>A React-based interface. Sends requests to the backend to retrieve analysis      results from SEIF and Sylvia.</li> <li>Pages like <code>Home.jsx</code>, <code>Upload.jsx</code>, <code>Visualizer.jsx</code> are typical.</li> <li>Utlizes ReactJS and React Router, to learn more about ReactJS - Click Here and  to learn more about React Router, Click Here </li> </ul>"},{"location":"repo_structure/#backend","title":"<code>backend/</code>","text":"<ul> <li><code>server.js</code> is the main entrypoint of the backend and is run when the pod is deployed.</li> <li><code>backend/uploads</code> is where the uploaded files from the frontend will be ultimitly stored before being sent to the SEIF or Sylvia APIs </li> <li>Talks to SEIF and Sylvia depeding on the users choice.</li> <li>Exposes endpoints that are designed for the frontend to send and recieve information.</li> <li>Utlizes ExpressJS for RestFUL API endpoints to delegate tasks to SEIF and Sylvia APIs respectfully.</li> </ul>"},{"location":"repo_structure/#githubworkflows","title":"<code>.github/workflows/</code>","text":"<ul> <li>Houses CI/CD config (like <code>cicd.yml</code>) for automatic deployment to OKD. See All About Deployment for more information.</li> </ul>"},{"location":"repo_structure/#how-it-works","title":"How It Works","text":"<ol> <li><code>Frontend</code> \u2192 user triggers \u201cAnalyze hardware design.\u201d</li> <li><code>Backend</code> \u2192 receives request, calls SEIF or calls Sylvia.</li> <li><code>SEIF</code> or <code>Sylvia</code> APIs \u2192 recieve request from the <code>backend</code> and process the files \u2192 then return JSON to later be displayed.</li> <li><code>Backend</code> \u2192 recieves the JSON and sends it back to <code>frontend</code>.</li> <li><code>Frontend</code> \u2192 recieves the JSON results and displays them,</li> </ol>"},{"location":"Deployment/deployment_intro/","title":"All about Deployment","text":"<p>Veriviz utilizes UNC Cloud Apps to host and deploy the service. UNC Cloud Apps runs on OKD (OpenShift Kubernetes Distribution). </p>"},{"location":"Deployment/deployment_intro/#what-is-kubernetes","title":"What is Kubernetes?","text":"<p>On a high level, Kubernetes is a service that allows your application to be run in a virtual environment with its own operating system. You can think of it as what a container is to Docker on your local machine \u2014 that's essentially what a pod is on a Kubernetes deployment. This is defined by a Dockerfile in your project which OKD uses to create your pod, and in which your code is processed and run.</p>"},{"location":"Deployment/deployment_intro/#how-does-deploying-on-kubernetes-work","title":"How does deploying on Kubernetes work","text":"<p>The OKD Deployment process works as follows:</p> <ol> <li>Being notified of CI successfully passing all tests on main and receiving a webhook callback  </li> <li>A BuildConfig begins a new Build by pulling the repository and building a Docker image  </li> <li>The Docker image is pushed to an ImageStream  </li> <li>The ImageStream notifies a Deployment that a new image is available  </li> <li>The Deployment spins up a new Pod (Container) based on the image  </li> <li>Once the new Pod is available, it turns off the old Pod running the previous version</li> </ol> <p>Credit to Kris Jordan and his website for this information</p>"},{"location":"Deployment/deployment_intro/#continuous-integration-continuous-deployment","title":"Continuous Integration, Continuous Deployment","text":"<p>CI/CD (Continuous Integration/Continuous Deployment) refers to the automated process of redeploying a service when new changes are made.</p> <ul> <li> <p>Continuous Integration refers to the process of verifying tests are passed before deployment. So for example, after a commit to main is made, tests you write will be automatically run on your new code. If these tests pass, great! They will now be handed over to continuous deployment; if not, your project will not be redeployed and you will have to iterate on your code until they pass.</p> </li> <li> <p>The second step of CI/CD is Continuous Deployment. This refers to the process of automatically redeploying your service to reflect the changes you made to it. In a full CI/CD pipeline, once your project has passed the tests, it is then deployed.</p> </li> </ul> <p>In Veriviz, Continuous Integration is NOT used. This means once new changes are reflected in the main branch, it will be redeployed to OKD, rebuilt, and up and running. There are no tests to verify your work. This can be added in the future but is not necessarily needed. Don\u2019t worry, if your code results in a failed deployment, OKD will revert to the last built pod and the service will still run on the old code. Keep in mind, bugs that do not result in a failed deployment will still be there.</p>"},{"location":"Deployment/how_to_deploy/","title":"Veriviz Continuous Deployment Setup Guide","text":"<p>Welcome to Veriviz! This guide will walk you through adding a new service to Veriviz and setting up Continuous Deployment (CD) on UNC\u2019s OKD platform. By the end, you\u2019ll have an automated pipeline that builds and deploys your new service whenever you push to <code>main</code>.</p>"},{"location":"Deployment/how_to_deploy/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Prerequisites</li> <li>Step 1: Create or Update Your Dockerfile</li> <li>Step 2: Set Up an OKD Project</li> <li>Step 3: Deploy the Service Manually Once</li> <li>Step 4: Expose a Route (Optional)</li> <li>Step 5: Create a Build Webhook Secret in OKD</li> <li>Step 6: Add the Webhook to GitHub Secrets</li> <li>Step 7: Configure GitHub Actions</li> <li>Step 8: Commit and Merge</li> <li>Step 9: Verify Your Deployment</li> <li>Optional: Adding Secrets (.env) to the Deployment</li> <li>Tips and Extras</li> </ol>"},{"location":"Deployment/how_to_deploy/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have GitHub access to the Veriviz repository (public or private).</li> <li>You have OKD/CloudApps access at UNC (make sure you can log in and select your project).</li> <li>You have a Dockerfile for your new service or can create one.</li> <li>You know the name of your new service, e.g. <code>veriviz-newservice</code>.</li> </ul>"},{"location":"Deployment/how_to_deploy/#step-1-create-or-update-your-dockerfile","title":"Step 1: Create or Update Your Dockerfile","text":"<ol> <li>Place a <code>Dockerfile</code> in your service\u2019s directory, e.g., <code>newservice/Dockerfile</code>.</li> <li>Example (Node/Express):    <pre><code>FROM node:20\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\nRUN npm install\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD [\\\"node\\\", \\\"server.js\\\"]\n</code></pre></li> <li>Adjust as needed for your framework (Python, Go, etc.).</li> </ol>"},{"location":"Deployment/how_to_deploy/#step-2-set-up-an-okd-project","title":"Step 2: Set Up an OKD Project","text":"<p>Log into OKD (UNC\u2019s CloudApps). NOTE: You Must be using eduroam wifi or the UNC VPN to be able to login on your CLI and on the cloudapps website. Learn more about the VPN here.</p> <ol> <li>Navigate to https://cloudapps.unc.edu/ and sign in</li> <li>Click on your ONYEN in the upper-right of the console and click <code>Copy Login Command</code></li> <li>Click <code>Display Token</code> and copy the <code>Login in with this token</code> token which should look like <code>oc login --token=&lt;YOUR_TOKEN&gt; --server=https://api.apps.unc.edu:6443</code></li> <li>Open up your project in its devcontainer making sure the OKD CLI is installed in the dev container (you can check this by running <code>oc version</code>)</li> <li>Log in with the follwoing commands and using your token you copied   <pre><code>oc login --token=&lt;YOUR_TOKEN&gt; --server=https://api.apps.unc.edu:6443\noc project &lt;YOUR_PROJECT_NAME&gt;\n</code></pre></li> <li>Confirm with <code>oc status</code></li> </ol>"},{"location":"Deployment/how_to_deploy/#step-3-deploy-the-service-manually-once","title":"Step 3: Deploy the Service Manually Once","text":"<p>This will create a BuildConfig, ImageStream, and Deployment for your new service: <pre><code>oc new-app https://github.com/&lt;user&gt;/&lt;repo&gt;.git#main \\\n  --context-dir=newservice \\\n  --name=veriviz-newservice \\\n  --strategy=docker \\\n  --labels=app=veriviz-newservice\n</code></pre></p> <ul> <li> <p><code>--context-dir=newservice</code>: Tells OKD to use your newservice folder with the Dockerfile inside. Exmaple for veriviz is <code>frontend</code>.</p> </li> <li> <p><code>--name=veriviz-newservice</code>: The name for your build &amp; deployment.</p> </li> </ul> <p>Check the status: <pre><code>oc logs -f buildconfig/veriviz-newservice\n</code></pre></p> <p>For Private Repositories</p> <p>If you repository is private, follow these instructions instead of Step 3. Only replace the step 3 instructions with these. Steps 1-2 and 4-12 stay the same. </p>"},{"location":"Deployment/how_to_deploy/#step-4-expose-a-route-optional","title":"Step 4: Expose a Route (Optional)","text":"<p>If your service needs to be accessible outside of OKD (e.g. from a frontend or public internet):</p> <p><pre><code>oc create route edge --service=veriviz-newservice --insecure-policy=Redirect\noc get route veriviz-newservice\n</code></pre> You\u2019ll see the URL for your service.</p> <p>Note</p> <p>If this service is internal-only, you can skip creating a route.</p>"},{"location":"Deployment/how_to_deploy/#step-5-create-a-build-webhook-secret-in-okd","title":"Step 5: Create a Build Webhook Secret in OKD","text":"<p>You want GitHub to trigger builds on pushes/merges. First, find your webhook URL:</p> <p><pre><code>oc describe bc/veriviz-newservice | grep -C 1 generic\noc get bc veriviz-newservice -o yaml | grep -C 1 generic\n</code></pre> You\u2019ll see something like: <pre><code>https://api.apps.unc.edu:6443/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/veriviz-newservice/webhooks/&lt;secret&gt;/generic\n</code></pre> Copy that URL.</p>"},{"location":"Deployment/how_to_deploy/#step-6-add-the-webhook-to-github-secrets","title":"Step 6: Add the Webhook to GitHub Secrets","text":"<ol> <li>Go to your GitHub Repo \u2192 Settings \u2192 Secrets and variables \u2192 Actions</li> <li>New Repository Secret:</li> <li>Name: <code>CD_BUILD_WEBHOOK_VERIVIZ_NEWSERVICE</code></li> <li>Value: (paste the full webhook URL)</li> </ol> <p>Name</p> <p>The name can be anything you want, but make it descirptive in case you dpeloy multiple services form one repo.</p>"},{"location":"Deployment/how_to_deploy/#step-7-configure-github-actions","title":"Step 7: Configure GitHub Actions","text":"<p>Create or edit your <code>.github/workflows/cicd.yml</code>. For example:</p> <pre><code>name: Veriviz CI/CD Pipeline\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  cd-veriviz-newservice:\n    name: \\\"Continuous Deployment - veriviz-newservice\\\"\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Trigger OKD Build\n        run: |\n          curl -X POST ${{ secrets.CD_BUILD_WEBHOOK_VERIVIZ_NEWSERVICE }}\n</code></pre>"},{"location":"Deployment/how_to_deploy/#step-8-commit-and-merge","title":"Step 8: Commit and Merge","text":"<ol> <li>Create a new branch, e.g. <code>feature/newservice-cd</code>.</li> <li>Push and open a Pull Request.</li> <li>Once merged into <code>main</code>, GitHub Actions will:</li> <li>Run the pipeline</li> <li>Hit the OKD webhook</li> <li>Trigger a new build &amp; deploy</li> </ol> <p>Note</p> <p>Alternatively, you can also push directly to the main branch to achieve the same result.</p>"},{"location":"Deployment/how_to_deploy/#step-9-verify-your-deployment","title":"Step 9: Verify Your Deployment","text":"<ul> <li>Check OKD builds: <pre><code>oc get builds\noc logs -f bc/veriviz-newservice\n</code></pre></li> <li>Check the service: <pre><code>oc get pods\noc logs deployment/veriviz-newservice\n</code></pre></li> <li>Check the route (if exposed): <pre><code>oc get route veriviz-newservice\n</code></pre> Confirm you can hit it in the browser.</li> </ul>"},{"location":"Deployment/how_to_deploy/#optional-adding-secrets-env-to-the-deployment","title":"Optional: Adding Secrets (.env) to the Deployment","text":"<p>If your new service requires environment variables:</p> <ol> <li>Create a .env in newservice/.env (don\u2019t commit to GitHub).</li> <li>In your dev container:   <pre><code>oc create secret generic veriviz-newservice-env --from-env-file=newservice/.env\noc set env deployment/veriviz-newservice --from=secret/veriviz-newservice-env\n</code></pre> replacing <code>veriviz-newservice-env</code> with the name you want for your secret.</li> <li>On redeploy, your app can read the environment variables inside the container.</li> </ol>"},{"location":"Deployment/how_to_deploy/#tips-and-extras","title":"Tips and Extras","text":""},{"location":"Deployment/how_to_deploy/#how-do-i-manually-rebuild-without-deleting-everything","title":"How do I manually rebuild without deleting everything?","text":"<p>Use: <pre><code>oc start-build veriviz-newservice\n</code></pre> Or trigger the webhook again:</p> <pre><code>curl -X POST &lt;your-webhook-URL&gt;\n</code></pre>"},{"location":"Deployment/how_to_deploy/#what-if-i-want-to-rename-or-delete-the-service","title":"What if I want to rename or delete the service?","text":"<p><pre><code>oc delete all -l app=veriviz-newservice\n</code></pre> This removes the BuildConfig, Deployment, Route, and Service labeled <code>app=veriviz-newservice</code>.</p>"},{"location":"Deployment/how_to_deploy/#what-if-my-repository-is-private","title":"What if my repository is private?","text":"<p>If Your Repository Is private, then OKD won\u2019t be able to automatically clone it unless you give it credentials. Here\u2019s how:</p> <ol> <li>Generate a GitHub Personal Access Token (classic) with repo read permissions.</li> <li>Go to your github profile -&gt; Developer Settings -&gt; Personal access tokens -&gt; Tokens(Classics) and copy the PAT after creation</li> <li>Create a secret in OKD:   <pre><code>oc create secret generic veriviz-newservice-pat \\\n  --from-literal=username=&lt;GITHUB_USERNAME&gt; \\\n  --from-literal=password=&lt;YOUR_PAT&gt;\n</code></pre></li> <li>Label the secret so OKD can find it:   <pre><code>oc label secret veriviz-newservice-pat app=veriviz-newservice\n</code></pre></li> <li> <p>Create the new app using the secret:   <pre><code>oc new-app https://github.com/&lt;user&gt;/&lt;private-repo&gt;.git#main \\\n  --context-dir=newservice \\\n  --name=veriviz-newservice \\\n  --strategy=docker \\\n  --source-secret=veriviz-newservice-pat \\\n  --labels=app=veriviz-newservice\n</code></pre></p> </li> <li> <p>The rest (webhook, route, secrets for .env) is the same as above.</p> </li> </ol> <p>Note</p> <p>The <code>--source-secret=veriviz-newservice-pat</code> is critical so OKD can clone your private repo.</p>"},{"location":"development/database/","title":"On the Database","text":"<p>Currently, Veriviz uses a PostgreSQL database hosted on a service called Neon. We\u2019re on Neon\u2019s free tier, which includes 0.5 GB of memory and limited read/write operations. This is a good starting point, but a more robust solution is definitely needed if you want to contribute or improve the project. It is recommended to start a new pod with a Postgres image downloaded on OKD so everything can be in one place.</p>"},{"location":"development/database/#database-table","title":"Database Table","text":"<p>Our main table holds the following columns:</p> id name date type json_data output_text PK JSON Graph Output Engine Output Text <ul> <li>id (primary key)</li> <li>name: User-defined name when submitting</li> <li>date: Date and timestamp of the submission</li> <li>type: Which engine the user selected (Sylvia or SEIF)</li> <li>json_data: JSON data returned from the engine to display the graph</li> <li>output_text: Console or text output from the engine</li> </ul>"},{"location":"development/database/#accessing-neon","title":"Accessing Neon","text":"<p>We have an account on neon.tech. If you need direct access to the Neon dashboard, please contact the team for credentials.</p>"},{"location":"development/database/#deployment-integration","title":"Deployment Integration","text":"<p>Our database connection string is stored in a private <code>.env</code> file. When deploying on OKD, we inject these environment variables into the container so the application can read them (e.g., via <code>process.env.DATABASE_URL</code>). This setup ensures that our DB credentials remain private, even though the rest of the code is public.</p>"},{"location":"development/devcontainers/","title":"What are Devcontainers and why are they useful?","text":"<p>A Devcontainer uses Docker to create a virtual environment while developing your  project. For example, you can run an Ubuntu environment with Python installed, and  no matter which machine (Windows, macOS, or Linux) you use, you\u2019ll have a consistent  setup.</p> <p>Benefits:</p> <ul> <li>Avoid \"it works on my machine\" issues.</li> <li>Simplify collaboration.</li> <li>Effortlessly include tools (like the OKD CLI) without manual installs.</li> </ul>"},{"location":"development/devcontainers/#using-devcontainers","title":"Using DevContainers","text":"<p>As you will see in Veriviz, there is a predefined devcontainer. Running it is the most important thing but if you would like to learn more and how to create one, read the <code>Creating a Devcontainer</code> section below.</p> <p>Prerequisties</p> <ul> <li>Docker is strictly nesseary to run a devcontainer and needs to be dowloaded. Check out here for download information(The free version is recommended). </li> <li>VsCode is highly recommended. This tutorial will assume you are using VsCode and using any other code editor for a devcontainer will require your own research.</li> <li>The Dev Containers Extension in VsCode is needed as well</li> </ul>"},{"location":"development/devcontainers/#re-opening-in-a-devcontainer","title":"Re-opening in a devcontainer","text":"<ol> <li>Press Ctrl+Shift+P (or Cmd+Shift+P on Mac) in VS Code.</li> <li>Choose \"Dev Containers: Reopen in Container\".</li> <li>VS Code reopens in your dev environment automatically.</li> </ol> <p>Note</p> <p>Sometimes, VS Code prompts \"Reopen folder to develop in a container?\". Clicking \"Reopen\" achienves the same result.</p>"},{"location":"development/devcontainers/#creating-a-devcontainer","title":"Creating a Devcontainer","text":"<p>As outlined earlier a devcontainer is extremly useful for collaboration and just a good quality of life thing to have for a repo. Below is an Example devcontainer steup for Rust that is not used in verviz but just her eto provide an example of how to set up a devcontainer.</p> <ol> <li>In VS Code, open your project via its root directory</li> <li>Install Dev Containers extension in VS Code</li> <li>create a <code>.devcontainer</code> directory in the root of your project which is the <code>rust-intro</code> directory we just made <pre><code>mkdir .devcontainer\n</code></pre> This tells the VsCode devcontainers extension there is a devcontainer and it will know to look here</li> <li>Use VS Code and create a file named <code>devcontainer.json</code> inside of the <code>.devcontainer</code> directory. This is where you will define what your devcontainer's skeleton. Look below for an example for a basic <code>Rust</code> container.</li> </ol> <p><pre><code>{\n    \"name\": \"Rust Intro\",\n    \"image\": \"mcr.microsoft.com/devcontainers/rust:latest\",\n    \"customizations\": {\n        \"vscode\":{\n            \"settings\": {},\n            \"extensions\":[\"rust-lang.rust-analyzer\"]\n        }\n    },    \n    \"postCreateCommand\": \"\",\n}\n</code></pre> Here's what everything does</p> <ul> <li> <p><code>name:</code> This is what your dev container will be named</p> </li> <li> <p><code>image:</code> The docker image to use, in this case we will be using a preconfigured image for rust by microsoft</p> </li> <li> <p><code>customizations:</code> Adds configurations like VS Code extensions ensuring other developers have them too. <code>rust-lang.rust-analyzer</code> is the standard language server for rust development in vs code.</p> </li> <li> <p><code>postCreateCommand:</code> An optional script to run on container creation</p> </li> </ul> <p>For more info, see VS Code\u2019s Devcontainers docs.</p>"},{"location":"development/running_locally/","title":"Running on your local machine","text":""},{"location":"development/running_locally/#running-veriviz","title":"Running Veriviz","text":"<ol> <li>Open a new terminal and run <code>cd frontend</code></li> <li>Run <code>npm install</code> to verify everything is installed</li> <li>Run <code>npm run dev</code>. Now the frontend is up and running on <code>http://localhost:5173/</code>.</li> <li>Now we want to run the backend. Open a new terminal(diffrent than the one you used for the previous steps) <code>cd ../backend</code> in your terminal</li> <li>Run <code>npm install</code> to verify everything is installed</li> <li>Run <code>node server.js</code>. Now the backend is up and running on <code>https://localhost:8000/</code>.</li> </ol> <p>Devcontainer not currently working</p> <p>Right now to use the dev contianer with sylvia, the frontend and backend, it requires extra docker networking configuration which is not currently added. You will have to install dependecies locally right now but when using OKD, use the devcontainer for editing the pods.</p> <p>When running a devcontainer, If step 3 is not working</p> <p>If it is not running on localhost:5173 check your CLI for the correct port. Then navigate to <code>.devcontainer/devcontainer.json</code> and change this line <code>\"forwardPorts\": [5173, 8000]</code> to  <code>\"forwardPorts\": [VITE_PORT_HERE, 8000]</code> where the <code>VITE_PORT_HERE</code> is the port where the app tried to run. Then navigate to <code>/frontend/vite.config.js</code> and change the line <code>port: 5173</code> to again, <code>port: VITE_PORT_HERE</code>. Rebuild the container through <code>ctrl + shft + p</code>(<code>cmnd + shft + p</code>for mac), and then typing Rebuild in container` and selecting that. Do NOT commit these changes to the remote repository but these changes should fix your project locally.</p> <p>When running a devcontainer, if step 6 is not working</p> <p>If it is not running on localhost:8000 check your CLI for the correct port. Then navigate to <code>.devcontainer/devcontainer.json</code> and change this line <code>\"forwardPorts\": [5173, 8000]</code> to  <code>\"forwardPorts\": [5173E, NODE_PORT_HERE]</code> where the <code>NODE_PORT_HERE</code> is the port where the app tried to run. Rebuild the container through <code>ctrl + shft + p</code>(<code>cmnd + shft + p</code>for mac), and then typing Rebuild in container` and selecting that. Do NOT commit these changes to the remote repository but these changes sould fix your project locally.</p> <p>Security Vulenerabilities</p> <p>When running <code>npm install</code>, if you see any messages in the CLI stating security vulnerabilities, run <code>npm audit fix</code>.</p>"},{"location":"development/running_locally/#running-sylvia","title":"Running Sylvia","text":"<ol> <li>Clone or Fork the Sylvia repository</li> <li>Run <code>pip install -r requirements.txt</code></li> <li>Run <code>uvicorn API.sylvia_api:app --host 127.0.0.1 --port 8001 --timeout-keep-alive 600</code></li> <li>View on <code>http://localhost:8001/docs</code> </li> </ol> <p>Devcontainer not currently working</p> <p>Right now to use the dev contianer with sylvia, the frontend and backend, it requires extra docker networking configuration which is not currently added. You will have to install dependecies locally right now but when using OKD, use the devcontainer for editing the pods.</p>"},{"location":"reference/seif/","title":"SEIF","text":"<p>SEIF (Symbolic Execution for Information Flow) is a tool that focuses on verifying and exploring how information flows through hardware designs:</p> <p>Read the paper here - It augments symbolic execution to account for data and control signals, ensuring   you can analyze potential leaks or unauthorized flows. - SEIF integrates with Sylvia to refine the exploration of flows and generate   more precise results.</p> <p>In Veriviz, SEIF is called from the backend to run advanced security checks. You can view or visualize the results via the Veriviz front end.</p>"},{"location":"reference/seif/#citation","title":"Citation","text":"<p>@inproceedings{ryan2023SEIF,   author    = {Ryan, Kaki and Gregoire, Matthew and Sturton, Cynthia},   title     = {{SEIF: Augmented} Symbolic Execution for Information Flow in Hardware Designs},   year      = {2023},   isbn      = {9798400716232},   publisher = {Association for Computing Machinery},   address   = {New York, NY, USA},   url       = {https://doi.org/10.1145/3623652.3623666},   doi       = {10.1145/3623652.3623666},   booktitle = {Proceedings of the 12th International Workshop on Hardware and Architectural Support for Security and Privacy (HASP)},   pages     = {1--9},   numpages  = {9},   keywords  = {path coverage, information flow, symbolic execution, hardware security},   location  = {Toronto, Canada}, }</p>"},{"location":"reference/sylvia/","title":"Sylvia","text":"<p>Sylvia is a symbolic execution engine built to handle Verilog RTL directly. It uses a strategy called piecewise composition to reduce the path-explosion  problem commonly seen in symbolic execution.</p> <ul> <li>Cycle-Accurate: It interprets hardware designs with clock-cycle precision.</li> <li>Scalable: By splitting logic into independent blocks, it minimizes redundant work.</li> </ul> <p>In Veriviz, Sylvia receives requests from SEIF, performs the necessary symbolic analysis, and returns the results to the Veriviz backend, which then forwards them to the front end for visualization.</p>"},{"location":"reference/sylvia/#citation","title":"Citation","text":"<p>@inproceedings{Ryan2023Sylvia, author = {Ryan, Kaki and Sturton, Cynthia}, title = {Sylvia: Countering the Path Explosion Problem in the Symbolic Execution of Hardware Designs}, year = {2023}, isbn = {978-3-85448-060-0}, publisher = {TU Wien Academic Press}, address = {New York, NY, USA}, url = {https://repositum.tuwien.at/handle/20.500.12708/188806 }, booktitle = {Proceedings of the 23rd Conference on Formal Methods in Computer-Aided Design (FMCAD)}, pages = {110--121}, numpages = {12}, series = {FMCAD} }</p>"}]}